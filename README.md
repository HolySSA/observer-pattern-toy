# 옵저버 패턴 토이 프로젝트

## 옵저버 패턴이란?

옵저버 패턴은 객체 간의 일대다(one-to-many) 의존성을 정의하는 디자인 패턴입니다. 한 객체(Subject)의 상태가 변경될 때, 그 객체에 의존하는 다른 객체들(Observers)에게 자동으로 알림을 보내고 업데이트하는 방식으로 동작합니다.

### 주요 구성 요소

1. **Subject (주제)**

   - 상태를 가지고 있는 객체
   - 옵저버들을 등록하고 관리
   - 상태 변경 시 옵저버들에게 알림

2. **Observer (관찰자)**
   - Subject의 상태 변경을 관찰하는 객체
   - Subject로부터 변경 알림을 받아 처리

## 프로젝트 구조

```
Observer/
├── Core/                 # 핵심 인터페이스
│   ├── IObserver.cs     # 옵저버 인터페이스
│   └── ISubject.cs      # 주제 인터페이스
├── Managers/            # 게임 관리자
│   └── GameManager.cs   # 게임 상태 관리 및 이벤트 발행
├── Observers/           # 옵저버 구현체들
│   ├── ScoreDisplay.cs  # 점수 표시
│   ├── AchievementSystem.cs # 업적 관리
│   └── SoundManager.cs  # 사운드 효과 관리
└── Program.cs           # 메인 프로그램
```

## 구현된 기능

1. **게임 이벤트 시스템**

   - 점수 획득
   - 플레이어 사망
   - 레벨 클리어

2. **옵저버 구현체**
   - `ScoreDisplay`: 점수 변경 시 화면에 표시
   - `AchievementSystem`: 게임 이벤트에 따른 업적 달성 처리
   - `SoundManager`: 이벤트에 따른 효과음 재생

## 실행 방법

```bash
cd Observer
dotnet run
```

## 실행 결과 예시

```
게임 시작!

플레이어가 점수를 획득합니다...
현재 점수: 100
업적 달성: 첫 점수 획득!
효과음 재생: 점수 획득!

플레이어가 사망했습니다...
업적 달성: 첫 사망!
효과음 재생: 플레이어 사망!

플레이어가 레벨을 클리어했습니다...
업적 달성: 첫 레벨 클리어!
효과음 재생: 레벨 클리어!
```

## 옵저버 패턴의 장점

1. **느슨한 결합 (Loose Coupling)**

   - Subject와 Observer가 서로 독립적으로 동작
   - Subject는 Observer의 존재를 알 필요 없음

2. **확장성**

   - 새로운 Observer를 쉽게 추가 가능
   - 기존 코드 수정 없이 기능 확장 가능

3. **유지보수성**
   - 각 컴포넌트의 책임이 명확히 분리됨
   - 코드의 재사용성 향상
